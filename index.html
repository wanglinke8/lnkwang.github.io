<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>粒子心形</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // 设置 canvas 尺寸
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // 心形参数
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) * 0.4;

    // 粒子数量
    const particleCount = 5000;
    const particles = [];

    // 随机生成粒子
    for (let i = 0; i < particleCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * radius * 1.2;
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;

      // 心形方程：r = a(1 - sin(θ))，但这里我们用变形处理
      // 用更直观的贝塞尔或参数化心形
      const heartShape = (t) => ({
        x: 16 * Math.pow(Math.sin(t), 3),
        y: 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)
      });

      // 生成在心形周围的点
      const t = Math.random() * Math.PI * 2;
      const point = heartShape(t);
      const scale = 1 + Math.random() * 0.5; // 大小变化
      const px = centerX + point.x * radius * scale;
      const py = centerY + point.y * radius * scale;

      // 添加随机偏移，模拟粒子感
      const offsetX = (Math.random() - 0.5) * radius * 0.4;
      const offsetY = (Math.random() - 0.5) * radius * 0.4;

      particles.push({
        x: px + offsetX,
        y: py + offsetY,
        size: Math.random() * 2 + 0.5,
        opacity: Math.random() * 0.7 + 0.3,
        color: '#00ffcc' // 青绿色
      });
    }

    // 动画循环
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      particles.forEach(particle => {
        // 轻微抖动
        const dx = (Math.random() - 0.5) * 0.5;
        const dy = (Math.random() - 0.5) * 0.5;

        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.opacity;
        ctx.beginPath();
        ctx.arc(
          particle.x + dx,
          particle.y + dy,
          particle.size,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
